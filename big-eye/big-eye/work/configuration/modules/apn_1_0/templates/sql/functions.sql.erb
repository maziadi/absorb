/*
 * APN functions specifics
 * IMPORTANT NOTE: for all modifications, see http://intranet.admin.alphalink.fr/documentation/APN#head-f4bae4d235eb4286986903195e4a9f7e842da3ba
 *
*/

/*
 * Create Pl/sh language
 * Needs postgresql-9.1-plsh debian package
*/
CREATE OR REPLACE FUNCTION pg_catalog.plsh_handler() RETURNS language_handler
  AS '$libdir/pgplsh'
  LANGUAGE C;

CREATE OR REPLACE FUNCTION pg_catalog.plsh_validator(oid) RETURNS void
  AS '$libdir/pgplsh'
  LANGUAGE C;

CREATE OR REPLACE LANGUAGE plsh
  HANDLER pg_catalog.plsh_handler
  VALIDATOR pg_catalog.plsh_validator;

/*
 * AUTH validation and process
 * Called by authorize_check_query (freeradius/sql.conf)
*/
CREATE OR REPLACE FUNCTION fct_shauth(ref varchar, ip varchar, mcc integer, timezone varchar, visprefrt varchar) RETURNS INTEGER AS $$
#!/bin/dash
/opt/local/bin/rad-auth.sh $*
echo $?
$$ LANGUAGE 'plsh' IMMUTABLE;

ALTER FUNCTION fct_shauth(ref varchar, ip varchar, mcc integer, timezone varchar, visprefrt varchar) OWNER TO <%= db_user %>;

CREATE OR REPLACE FUNCTION fct_pgauth(usr varchar, pmcc integer, timezone varchar) RETURNS SETOF RECORD AS $$
DECLARE
  reference varchar;
  ip varchar;
  valid integer;
  nsent integer;
  etat varchar;
  visp varchar;
  ongoing boolean;
BEGIN
  IF pmcc != 20810 THEN
    SELECT count(*) INTO nsent FROM radacct WHERE radacct.sent = false AND radacct.username = usr AND radacct.mcc = pmcc;
  ELSE
    nsent = 0;
  END IF; 
  IF nsent != 0 or usr IS NULL THEN
    RAISE WARNING '[% roaming] AUTH refused, % report(s) unsent', usr, nsent;
    RETURN QUERY SELECT id, username, attribute, value, op FROM radcheck WHERE username = ''; 
  ELSE
    SELECT ref INTO reference FROM radcheck WHERE radcheck.username = usr LIMIT 1;
    IF reference IS NULL OR pmcc = 0 THEN
      RETURN QUERY SELECT id, username, attribute, value, op FROM radcheck WHERE username = ''; 
    ELSE

        valid = 0;
        SELECT state INTO etat FROM radcheck WHERE radcheck.username = usr LIMIT 1;
        SELECT acctsession INTO ongoing FROM refmsisdn WHERE refmsisdn.ref = reference;
        IF etat = 'A' AND ongoing = false THEN
          -- call to external script for TAXATION, PASDARAN and BASIJ process
          SELECT value INTO ip FROM radreply WHERE radreply.username = usr AND radreply.attribute = 'Framed-IP-Address';
          SELECT visprefrt INTO visp FROM refmsisdn LEFT JOIN rtvisp ON refmsisdn.visprefsi = rtvisp.visprefsi WHERE ref = reference;
          SELECT fct_shauth(reference, ip, pmcc, timezone, coalesce(visp, 'nil')) INTO valid;
        END IF; 

        -- returns radius auth fields
        IF valid = 1 THEN
          RETURN QUERY SELECT id, username, attribute, value, op FROM radcheck WHERE radcheck.username = usr  ORDER BY id; 
        ELSE
          RETURN QUERY SELECT id, username, attribute, value, op FROM radcheck WHERE username = ''; 
        END IF; 

    END IF; 
  END IF; 
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION fct_pgauth(usr varchar, pmcc integer, timezone varchar) OWNER TO <%= db_user %>;

/*
 * ACCT STOP process
 * Called by accounting_stop_query (freeradius/sql.conf)
*/
CREATE OR REPLACE FUNCTION fct_shacctstop(ref varchar, ip varchar, mcc integer, rx bigint, tx bigint, datets timestamp, msisdn varchar, sessiontime bigint, timezone varchar, visprefrt varchar) RETURNS INTEGER AS $$
#!/bin/dash
# datets=date' 'time
/opt/local/bin/rad-acctstop.sh $*
echo $?
$$ LANGUAGE 'plsh' IMMUTABLE;

ALTER FUNCTION fct_shacctstop(ref varchar, ip varchar, mcc integer, rx bigint, tx bigint, datets timestamp, msisdn varchar, sessiontime bigint, timezone varchar, visprefrt varchar) OWNER TO <%= db_user %>;

CREATE OR REPLACE FUNCTION fct_radius_acctstop(AcctSessionId varchar, AcctUniqueId varchar, UserName varchar, NASIPAddress inet, AcctStopTime timestamp, AcctDelayTime interval, AcctSessionTime bigint, AcctInputOctets bigint, AcctOutputOctets bigint, AcctTerminateCause varchar, ConnectInfo_stop varchar, mcc integer, timezone varchar) RETURNS VOID AS $$
DECLARE
  sessiontime bigint;
  stoptime timestamp;
  starttime timestamp;
  reference varchar;
  ip varchar;
  valid integer;
  pmsisdn varchar;
  visp varchar;
  nstop integer;
BEGIN

  -- check if a STOP has been already received for this session
  SELECT count(*) INTO nstop FROM radacct WHERE radacct.acctsessionid = $1 AND radacct.acctstoptime IS NOT NULL AND radacct.acctstarttime IS NULL;
  IF nstop != 0 THEN
    RAISE WARNING '[%] second STOP received for session %: ignored', $3, $1;
  ELSE
    -- radacct insert new STOP
    SELECT AcctStartTime INTO starttime FROM radacct WHERE radacct.AcctUniqueId = $2 AND radacct.UserName = $3;
    IF AcctSessionTime = 0 THEN
      sessiontime = EXTRACT(EPOCH FROM (AcctStopTime - starttime - AcctDelayTime))::BIGINT;
    ELSE
      sessiontime = AcctSessionTime;
    END IF;
    stoptime = AcctStopTime - AcctDelayTime;
    INSERT INTO radacct (AcctSessionId, AcctUniqueId, UserName, NASIPAddress, AcctStopTime, AcctSessionTime, AcctInputOctets, AcctOutputOctets, AcctTerminateCause, AcctStopDelay, ConnectInfo_stop, Mcc, Timezone) VALUES (AcctSessionId, AcctUniqueId, UserName, NASIPAddress, stoptime, sessiontime, AcctInputOctets, AcctOutputOctets, AcctTerminateCause, EXTRACT(EPOCH FROM(AcctDelayTime))::INT, ConnectInfo_stop, mcc, timezone);

    -- call to external script for TAXATION, PASDARAN and BASIJ process
    SELECT ref INTO reference FROM radcheck WHERE radcheck.username = $3;
    SELECT msisdn INTO pmsisdn FROM refmsisdn WHERE refmsisdn.ref = reference;
    SELECT value INTO ip FROM radreply WHERE radreply.username = $3 AND radreply.attribute = 'Framed-IP-Address';
    SELECT visprefrt INTO visp FROM refmsisdn LEFT JOIN rtvisp ON refmsisdn.visprefsi = rtvisp.visprefsi WHERE ref = reference;
    SELECT fct_shacctstop(reference, ip, mcc, AcctInputOctets, AcctOutputOctets, stoptime, pmsisdn, AcctSessionTime, timezone, coalesce(visp, 'nil')) INTO valid;
    IF valid = 1 THEN
      UPDATE radacct SET sent = true WHERE radacct.AcctUniqueId = $2 AND radacct.UserName = $3;
    END IF;
  END IF;
END;
$$ LANGUAGE plpgsql;

/*
 * radcheck trigger : update updatedate field
 * triggered by:
 *  - prov-apn
*/
CREATE OR REPLACE FUNCTION fct_radcheck_updatedate() RETURNS trigger AS $$
BEGIN
    NEW.updatedat = now();
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql' IMMUTABLE;

ALTER FUNCTION fct_radcheck_updatedate() OWNER TO <%= db_user %>;

DROP TRIGGER IF EXISTS trg_radcheck_updatedate ON radcheck RESTRICT;
CREATE TRIGGER trg_radcheck_updatedate BEFORE UPDATE
ON radcheck
FOR EACH ROW
EXECUTE PROCEDURE fct_radcheck_updatedate();

/*
 * radacct trigger
 *  - update visp reference (FRD option) when ACCT-START or ACCT-STOP occures
 *  - set/unset active session flag in mobile accounts table (refmsisdn)
 *  - update last accounting session id in refmsisdn
 * triggered by:
 *  - radius ACCT-START/STOP sessions
*/
CREATE OR REPLACE FUNCTION fct_radacct_updatefrd() RETURNS trigger AS $$
DECLARE
  visp varchar;
BEGIN
  -- update visprefsi (it may have changed during session)
  SELECT rtvisp.visprefsi INTO visp FROM refmsisdn LEFT JOIN rtvisp ON refmsisdn.visprefsi = rtvisp.visprefsi WHERE msisdn = split_part(NEW.username, '-', 1);
  NEW.visprefsi = visp;

  -- set session active/inactive in refmsisdn
  IF NEW.acctstarttime IS NOT NULL THEN
    UPDATE refmsisdn SET acctsession = true, lastacctsessionid = NEW.acctsessionid WHERE msisdn = split_part(NEW.username, '-', 1);
  ELSE
    UPDATE refmsisdn SET acctsession = false, lastacctsessionid = NEW.acctsessionid WHERE msisdn = split_part(NEW.username, '-', 1);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE 'plpgsql' VOLATILE;

ALTER FUNCTION fct_radacct_updatefrd() OWNER TO <%= db_user %>;

DROP TRIGGER IF EXISTS trg_radacct_updatefrd ON radacct RESTRICT;
CREATE TRIGGER trg_radacct_updatefrd BEFORE INSERT
ON radacct
FOR EACH ROW
EXECUTE PROCEDURE fct_radacct_updatefrd();

/*
 * refmsisdn trigger
 *  - update routing (PASDARAN request) on FRD option change if session is active
 * triggered by:
 *  - prov-apn
*/
CREATE OR REPLACE FUNCTION sh_refmsisdn_updatefrd(old_visprefrt varchar, new_visprefrt varchar, old_visprefsi varchar, new_visprefsi varchar, ip varchar, ref varchar) RETURNS INTEGER AS $$
#!/bin/dash
/opt/local/bin/frd-update.sh $*
echo $?
$$ LANGUAGE 'plsh' IMMUTABLE;

ALTER FUNCTION sh_refmsisdn_updatefrd(old_visprefrt varchar, new_visprefrt varchar, old_visprefsi varchar, new_visprefsi varchar, ip varchar, ref varchar) OWNER TO <%= db_user %>;

CREATE OR REPLACE FUNCTION fct_refmsisdn_updatefrd() RETURNS trigger AS $$
DECLARE
  old_visprefrt varchar;
  new_visprefrt varchar;
  ip varchar;
  valid integer;
BEGIN
  IF coalesce(OLD.visprefsi, 'nil') != coalesce(NEW.visprefsi, 'nil') AND NEW.acctsession = true THEN
    -- change routing only if visprefsi has changed
    SELECT visprefrt INTO old_visprefrt FROM rtvisp WHERE visprefsi = OLD.visprefsi;
    SELECT visprefrt INTO new_visprefrt FROM rtvisp WHERE visprefsi = NEW.visprefsi;
    SELECT value INTO ip FROM refmsisdn LEFT JOIN radreply ON refmsisdn.msisdn = split_part(radreply.username, '-', 1) WHERE radreply.attribute = 'Framed-IP-Address' AND refmsisdn.ref = NEW.ref LIMIT 1;
    SELECT sh_refmsisdn_updatefrd(coalesce(old_visprefrt, 'nil'), coalesce(new_visprefrt, 'nil'), coalesce(OLD.visprefsi, 'nil'), coalesce(NEW.visprefsi, 'nil'), ip, NEW.ref) INTO valid;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE 'plpgsql' IMMUTABLE;

ALTER FUNCTION fct_refmsisdn_updatefrd() OWNER TO radius;

DROP TRIGGER IF EXISTS trg_refmsisdn_updatefrd ON refmsisdn RESTRICT;
CREATE TRIGGER trg_refmsisdn_updatefrd BEFORE UPDATE
ON refmsisdn
FOR EACH ROW
EXECUTE PROCEDURE fct_refmsisdn_updatefrd();
